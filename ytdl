__dependencies__ = []

import os
import asyncio
import tempfile
import random
import string
import re
import json
from hikka import loader, utils

@loader.tds
class YTDLPMod(loader.Module):
    """üì• –°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ yt-dlp"""
    strings = {"name": "YTDLP"}

    async def client_ready(self, client, db):
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ yt-dlp
        try:
            process = await asyncio.create_subprocess_shell(
                "which yt-dlp",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await process.communicate()
            if not stdout:
                raise Exception("yt-dlp not found")
        except:
            raise Exception("‚ùå yt-dlp –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!\n–£—Å—Ç–∞–Ω–æ–≤–∏: pkg install yt-dlp")

    def rand(self, size=6):
        return ''.join(random.choices(string.ascii_lowercase + string.digits, k=size))

    async def _try_download(self, url, path, format_spec, message):
        """–ü–æ–ø—ã—Ç–∫–∞ —Å–∫–∞—á–∞—Ç—å —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º —Ñ–æ—Ä–º–∞—Ç–æ–º"""
        cmd = f'yt-dlp -f "{format_spec}" ' \
              f'--no-playlist ' \
              f'--check-formats ' \
              f'--force-ipv4 ' \
              f'--fragment-retries 15 ' \
              f'--retries 15 ' \
              f'--file-access-retries 15 ' \
              f'--extractor-retries 15 ' \
              f'--skip-unavailable-fragments ' \
              f'--no-check-certificate ' \
              f'--geo-bypass ' \
              f'--user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" ' \
              f'--add-header "Accept-Language: en-US,en;q=0.9" ' \
              f'-o "{path}" "{url}"'

        process = await asyncio.create_subprocess_shell(
            cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.STDOUT
        )

        output_lines = []
        try:
            while True:
                line = await process.stdout.readline()
                if not line:
                    break
                line = line.decode('utf-8', errors='ignore').strip()
                if line:
                    output_lines.append(line)
                    
                    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                    if len(output_lines) % 3 == 0:
                        display = "\n".join(output_lines[-3:])
                        if len(display) > 300:
                            display = display[-297:] + "..."
                        await message.edit(f"üì• –ü—Ä–æ–±—É—é —Ñ–æ—Ä–º–∞—Ç {format_spec}...\n```\n{display}\n```")
        except:
            pass

        await process.wait()
        return output_lines

    @loader.command()
    async def ytdl(self, message):
        """<—Å—Å—ã–ª–∫–∞> - —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ"""
        args = utils.get_args_raw(message)
        if not args:
            await message.edit("üíÄ –î–∞–π —Å—Å—ã–ª–∫—É, —É–Ω–∏—Ç–∞–∑ üòè")
            return

        url = args.strip()
        
        await message.edit("üì• –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ...")

        # –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
        list_cmd = f'yt-dlp --list-formats --no-playlist "{url}"'
        list_process = await asyncio.create_subprocess_shell(
            list_cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        try:
            stdout, stderr = await asyncio.wait_for(
                list_process.communicate(), timeout=30
            )
            formats_output = stdout.decode('utf-8', errors='ignore')
            
            # –ò—â–µ–º WebM —Ñ–æ—Ä–º–∞—Ç—ã (–æ–Ω–∏ —á–∞—Å—Ç–æ —Ä–∞–±–æ—Ç–∞—é—Ç –ª—É—á—à–µ)
            webm_formats = re.findall(r'^(\d+)\s+.*webm.*video only', formats_output, re.MULTILINE)
            mp4_formats = re.findall(r'^(\d+)\s+.*mp4.*video only', formats_output, re.MULTILINE)
            
            await message.edit(f"üì• –ù–∞–π–¥–µ–Ω–æ —Ñ–æ—Ä–º–∞—Ç–æ–≤: WebM: {len(webm_formats)}, MP4: {len(mp4_formats)}")
        except:
            webm_formats = []
            mp4_formats = []

        # –°–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º–∞—Ç–æ–≤ –¥–ª—è –ø–æ–ø—ã—Ç–æ–∫ –≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
        format_attempts = [
            "best[ext=webm]/best",  # –°–Ω–∞—á–∞–ª–∞ WebM
            "best[ext=mp4]/best",   # –ü–æ—Ç–æ–º MP4
            "worst[ext=webm]/worst",  # –ï—Å–ª–∏ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–±—É–µ–º —Ö—É–¥—à–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ
            "worst[ext=mp4]/worst",
            "bestaudio/best",  # –ï—Å–ª–∏ —Å–æ–≤—Å–µ–º –ø–ª–æ—Ö–æ, –∫–∞—á–∞–µ–º —Ç–æ–ª—å–∫–æ –∞—É–¥–∏–æ
        ]
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ ID —Ñ–æ—Ä–º–∞—Ç–æ–≤ –µ—Å–ª–∏ –Ω–∞—à–ª–∏
        if webm_formats:
            format_attempts.insert(0, f"{webm_formats[0]}+bestaudio")
        if mp4_formats:
            format_attempts.append(f"{mp4_formats[0]}+bestaudio")

        success = False
        last_error = ""
        
        for i, format_spec in enumerate(format_attempts):
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –ø—É—Ç—å –¥–ª—è –∫–∞–∂–¥–æ–π –ø–æ–ø—ã—Ç–∫–∏
            current_path = os.path.join(tempfile.gettempdir(), f"video_{self.rand(10)}.mp4")
            
            await message.edit(f"üì• –ü–æ–ø—ã—Ç–∫–∞ {i+1}/{len(format_attempts)}\n–§–æ—Ä–º–∞—Ç: {format_spec}")
            
            output_lines = await self._try_download(url, current_path, format_spec, message)
            
            if os.path.exists(current_path) and os.path.getsize(current_path) > 1024:  # –±–æ–ª—å—à–µ 1KB
                success = True
                path = current_path
                break
            else:
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—à–∏–±–∫—É
                last_error = "\n".join(output_lines[-5:]) if output_lines else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"
                # –£–¥–∞–ª—è–µ–º –ø—É—Å—Ç–æ–π —Ñ–∞–π–ª
                try:
                    os.remove(current_path)
                except:
                    pass

        if not success:
            await message.edit(f"üíÄ –í—Å–µ —Ñ–æ—Ä–º–∞—Ç—ã –Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç\n\n–ü–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞:\n```\n{last_error[:500]}\n```")
            return

        try:
            file_size = os.path.getsize(path) / (1024 * 1024)
            
            await message.edit(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ! ({file_size:.1f} –ú–ë)\nüì§ –û—Ç–ø—Ä–∞–≤–ª—è—é...")
            
            await message.client.send_file(
                message.chat_id, 
                path,
                caption=f"üé¨ {url[:50]}...\nüì¶ {file_size:.1f} –ú–ë"
            )
            await message.delete()
        except Exception as e:
            await message.edit(f"üíÄ –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")
        finally:
            try:
                os.remove(path)
            except:
                pass

    @loader.command()
    async def ytwebm(self, message):
        """<—Å—Å—ã–ª–∫–∞> - —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ –≤ WebM —Ñ–æ—Ä–º–∞—Ç–µ"""
        args = utils.get_args_raw(message)
        if not args:
            await message.edit("üíÄ –î–∞–π —Å—Å—ã–ª–∫—É, —É–Ω–∏—Ç–∞–∑ üòè")
            return

        url = args.strip()
        path = os.path.join(tempfile.gettempdir(), f"video_{self.rand(10)}.webm")

        await message.edit("üì• –ö–∞—á–∞—é –≤ WebM —Ñ–æ—Ä–º–∞—Ç–µ...")

        # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è WebM —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
        cmd = f'yt-dlp -f "bestvideo[ext=webm]+bestaudio[ext=webm]/best[ext=webm]/best" ' \
              f'--no-playlist ' \
              f'--force-ipv4 ' \
              f'--fragment-retries 20 ' \
              f'--retries 20 ' \
              f'--no-check-certificate ' \
              f'--geo-bypass ' \
              f'--user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" ' \
              f'-o "{path}" "{url}"'

        process = await asyncio.create_subprocess_shell(
            cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.STDOUT
        )

        output_lines = []
        try:
            while True:
                line = await process.stdout.readline()
                if not line:
                    break
                line = line.decode('utf-8', errors='ignore').strip()
                if line:
                    output_lines.append(line)
                    if len(output_lines) % 3 == 0:
                        display = "\n".join(output_lines[-3:])
                        await message.edit(f"üì• –ö–∞—á–∞—é WebM...\n```\n{display}\n```")
        except:
            pass

        await process.wait()

        if not os.path.exists(path) or os.path.getsize(path) == 0:
            await message.edit(f"üíÄ –ù–µ —Å–∫–∞—á–∞–ª–æ—Å—å\n\n{output_lines[-3:] if output_lines else '–û—à–∏–±–∫–∞'}")
            return

        try:
            file_size = os.path.getsize(path) / (1024 * 1024)
            await message.client.send_file(
                message.chat_id, 
                path,
                caption=f"üé¨ {url[:50]}... (WebM)\nüì¶ {file_size:.1f} –ú–ë"
            )
            await message.delete()
        except Exception as e:
            await message.edit(f"üíÄ –û—à–∏–±–∫–∞: {e}")
        finally:
            try:
                os.remove(path)
            except:
                pass

    @loader.command()
    async def ytmp3(self, message):
        """<—Å—Å—ã–ª–∫–∞> - —Å–∫–∞—á–∞—Ç—å –∞—É–¥–∏–æ –≤ MP3"""
        args = utils.get_args_raw(message)
        if not args:
            await message.edit("üíÄ –î–∞–π —Å—Å—ã–ª–∫—É, —É–Ω–∏—Ç–∞–∑ üòè")
            return

        url = args.strip()
        path = os.path.join(tempfile.gettempdir(), f"audio_{self.rand(10)}.mp3")

        await message.edit("üéµ –ö–∞—á–∞—é –∞—É–¥–∏–æ...")

        # –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è –∞—É–¥–∏–æ
        cmd = f'yt-dlp -x --audio-format mp3 ' \
              f'--audio-quality 0 ' \
              f'--no-playlist ' \
              f'--force-ipv4 ' \
              f'--fragment-retries 15 ' \
              f'--retries 15 ' \
              f'--no-check-certificate ' \
              f'--geo-bypass ' \
              f'--user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" ' \
              f'-o "{path}" "{url}"'

        process = await asyncio.create_subprocess_shell(
            cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.STDOUT
        )

        output_lines = []
        try:
            while True:
                line = await process.stdout.readline()
                if not line:
                    break
                line = line.decode('utf-8', errors='ignore').strip()
                if line:
                    output_lines.append(line)
                    if len(output_lines) % 3 == 0:
                        display = "\n".join(output_lines[-3:])
                        await message.edit(f"üéµ –ö–∞—á–∞—é –∞—É–¥–∏–æ...\n```\n{display}\n```")
        except:
            pass

        await process.wait()

        if not os.path.exists(path) or os.path.getsize(path) == 0:
            await message.edit(f"üíÄ –ù–µ —Å–∫–∞—á–∞–ª–æ—Å—å\n\n{output_lines[-3:] if output_lines else '–û—à–∏–±–∫–∞'}")
            return

        try:
            file_size = os.path.getsize(path) / (1024 * 1024)
            await message.client.send_file(
                message.chat_id, 
                path,
                caption=f"üéµ {url[:50]}...\nüì¶ {file_size:.1f} –ú–ë"
            )
            await message.delete()
        except Exception as e:
            await message.edit(f"üíÄ –û—à–∏–±–∫–∞: {e}")
        finally:
            try:
                os.remove(path)
            except:
                pass
